<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SonicChat Pro - Single Sync</title>
    <style>
        * { box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            background: #0b141a; 
            color: #e9edef; 
            margin: 0; 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            overflow: hidden;
        }
        header { 
            background: #202c33; 
            padding: 15px; 
            text-align: center; 
            font-weight: bold; 
            color: #00a884;
            border-bottom: 1px solid #3b4a54;
        }

        /* --- VU METER --- */
        #vu-container {
            width: 100%;
            height: 10px;
            background: #182229;
            border-bottom: 1px solid #3b4a54;
            position: relative;
            overflow: hidden;
        }
        #vu-bar {
            height: 100%;
            width: 0%;
            transition: width 0.05s ease-out;
            background: linear-gradient(to right, #00a884, #ffbc00, #ff3b3b);
        }
        #vu-bar.active { background: #00a884; }

        #chat-window { 
            flex: 1; 
            overflow-y: auto; 
            padding: 20px; 
            display: flex; 
            flex-direction: column; 
            gap: 12px;
            background-image: radial-gradient(#202c33 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .bubble { 
            max-width: 80%; 
            padding: 10px 15px; 
            border-radius: 15px; 
            font-size: 16px; 
            line-height: 1.4;
            word-wrap: break-word;
            animation: fadeIn 0.2s ease;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        .sent { align-self: flex-end; background: #005c4b; border-bottom-right-radius: 2px; }
        .received { align-self: flex-start; background: #202c33; border-bottom-left-radius: 2px; }
        
        .input-area { 
            background: #202c33; 
            padding: 12px 15px; 
            display: flex; 
            align-items: center; 
            gap: 10px;
        }
        input[type="text"] { 
            flex: 1; 
            background: #2a3942; 
            border: none; 
            padding: 12px 18px; 
            border-radius: 25px; 
            color: white; 
            outline: none;
            font-size: 16px;
        }
        .btn-round { 
            background: #00a884; border: none; width: 48px; height: 48px; border-radius: 50%; color: #0b141a; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; 
        }
        #btnSettings { background: #3b4a54; color: white; width: 40px; height: 40px; }

        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85);
            align-items: center; justify-content: center;
        }
        .modal-content {
            background: #232d36; padding: 25px; border-radius: 15px; width: 85%; max-width: 350px; text-align: center; border: 1px solid #3b4a54;
        }
        .setting-row { margin: 20px 0; display: flex; flex-direction: column; gap: 10px; }
        .setting-row input {
            background: #2a3942; border: 1px solid #00a884; color: white; padding: 10px; border-radius: 8px; text-align: center; font-size: 18px;
        }
        .btn-action {
            background: #00a884; border: none; padding: 12px; border-radius: 8px; color: #0b141a; font-weight: bold; cursor: pointer; width: 100%; margin-bottom: 10px;
        }
        .btn-secondary { background: #3b4a54; color: white; }
        .status-bar { font-size: 12px; background: #182229; padding: 6px; text-align: center; color: #8696a0; }
    </style>
</head>
<body>

<header>HzChat</header>
<div id="vu-container"><div id="vu-bar"></div></div>
<div class="status-bar" id="micStatus">PrÃªt</div>

<div id="chat-window">
    <div class="bubble received">Canal</div>
</div>

<div class="input-area">
    <button id="btnSettings" class="btn-round" onclick="toggleModal(true)">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M12 15.5a3.5 3.5 0 1 1 0-7 3.5 3.5 0 0 1 0 7zm7-3.5c0-.4-.05-.8-.13-1.2l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.31-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65A.488.488 0 0 0 12.45 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.22-.09-.49 0-.61.22l-2 3.46c-.12.22-.07.49.12.64L5.13 10.8c-.08.4-.13.8-.13 1.2s.05.8.13 1.2l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.31.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.22.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65c.08-.4.13-.8.13-1.2z"/></svg>
    </button>
    <input type="text" id="inputText" placeholder="Message..." autocomplete="off">
    <button class="btn-round" onclick="sendSound()">
        <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M1.101 21.757L23.8 12.028 1.101 2.3 l.011 7.912 13.623 1.816-13.623 1.817-.011 7.912z"></path></svg>
    </button>
</div>

<div id="settingsModal" class="modal">
    <div class="modal-content">
        <h2 style="color:#00a884; margin:0;">ParamÃ¨tres</h2>
        <div class="setting-row">
            <label style="color:#8696a0;">Offset Canal (Hz)</label>
            <input type="number" id="freqOffsetInput" value="0" onchange="updateOffset()">
        </div>
        <button class="btn-action" onclick="calibrate()">Calibrer Micro</button>
        <button class="btn-action btn-secondary" onclick="resetCalibration()">RÃ©initialiser</button>
        <div style="margin-top:15px; color:#8696a0; cursor:pointer;" onclick="toggleModal(false)">Fermer</div>
    </div>
</div>

<script>
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let analyser, dataArray, bufferLength;
    let isListening = false, isSending = false, isCalibrating = false;
    let dynamicThreshold = 45;
    
    let FREQ_OFFSET = 0;
    const STEP_FREQ = 40; 
    const CHAR_DURATION = 0.08; 
    const RAMP_TIME = 0.005;

    // LE BIP UNIQUE DE SYNCHRO
    const FREQ_SYNC = 1600; 

    const chatWindow = document.getElementById('chat-window');
    const micStatus = document.getElementById('micStatus');
    const vuBar = document.getElementById('vu-bar');
    const modal = document.getElementById('settingsModal');

    function toggleModal(show) { modal.style.display = show ? 'flex' : 'none'; }
    function updateOffset() { FREQ_OFFSET = parseInt(document.getElementById('freqOffsetInput').value) || 0; }
    function resetCalibration() { dynamicThreshold = 45; micStatus.innerText = "Reset (45)"; }

    function playTone(freq, startTime, duration) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.frequency.setValueAtTime(freq, startTime);
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.4, startTime + RAMP_TIME);
        gain.gain.setValueAtTime(0.4, startTime + duration - RAMP_TIME);
        gain.gain.linearRampToValueAtTime(0, startTime + duration);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(startTime); osc.stop(startTime + duration);
    }

    function sendSound() {
        const input = document.getElementById('inputText');
        const text = input.value.trim();
        if (!text || isSending) return;
        isSending = true; 
        addMessage(text, 'sent');
        input.value = '';
        
        let time = audioCtx.currentTime + 0.05;
        
        // 1. Un seul bip de dÃ©part
        playTone(FREQ_SYNC + FREQ_OFFSET, time, CHAR_DURATION);
        time += CHAR_DURATION;

        // 2. Les donnÃ©es
        text.split('').forEach(char => {
            const freq = (2000 + FREQ_OFFSET) + (char.charCodeAt(0) * STEP_FREQ);
            playTone(freq, time, CHAR_DURATION);
            time += CHAR_DURATION; 
        });

        setTimeout(() => { isSending = false; }, (time - audioCtx.currentTime) * 1000 + 100);
    }

    async function startListening() {
        if(isListening) return;
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
            const source = audioCtx.createMediaStreamSource(stream);
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 2048; 
            source.connect(analyser);
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            
            let currentWord = "", lastCharTime = 0, isRecording = false;

            function process() {
                if (isSending || isCalibrating) { 
                    vuBar.style.width = "0%";
                    requestAnimationFrame(process); return; 
                }

                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for(let i=0; i<bufferLength; i++) sum += dataArray[i];
                vuBar.style.width = Math.min(100, (sum / bufferLength) * 4) + "%";

                let highVal = 0, highIdx = -1;
                const minBin = Math.floor((1400 + FREQ_OFFSET) / (audioCtx.sampleRate / analyser.fftSize));
                
                for (let i = minBin; i < bufferLength; i++) {
                    if (dataArray[i] > highVal && dataArray[i] > dynamicThreshold) {
                        highVal = dataArray[i]; highIdx = i;
                    }
                }

                if (highIdx > -1) {
                    const freq = highIdx * (audioCtx.sampleRate / 2) / bufferLength;
                    const now = Date.now();

                    // DÃ©tection du bip unique de synchro
                    if (!isRecording && Math.abs(freq - (FREQ_SYNC + FREQ_OFFSET)) < 40) {
                        isRecording = true;
                        currentWord = "";
                        lastCharTime = now;
                        micStatus.innerText = "ðŸ”“ SynchronisÃ©";
                        vuBar.classList.add('active');
                    } 
                    // DÃ©tection des caractÃ¨res
                    else if (isRecording && freq >= (2000 + FREQ_OFFSET - 20)) {
                        const code = Math.round((freq - (2000 + FREQ_OFFSET)) / STEP_FREQ);
                        if (code >= 32 && code <= 255) {
                            if (now - lastCharTime >= (CHAR_DURATION * 1000 * 0.85)) { 
                                currentWord += String.fromCharCode(code);
                                lastCharTime = now;
                            }
                        }
                    }
                }

                // Fin automatique aprÃ¨s 1s de silence
                if (isRecording && (Date.now() - lastCharTime > 1000)) {
                    if (currentWord) addMessage(currentWord, 'received');
                    isRecording = false;
                    vuBar.classList.remove('active');
                    micStatus.innerText = "ðŸŽ¤ Ã‰coute";
                }

                requestAnimationFrame(process);
            }
            process(); isListening = true; micStatus.innerText = "ðŸŽ¤ Ã‰coute active";
        } catch (err) { micStatus.innerText = "âš ï¸ Erreur micro"; }
    }

    function calibrate() {
        if (!isListening) startListening();
        isCalibrating = true; toggleModal(false);
        micStatus.innerText = "â³ Silence...";
        let maxNoise = 0, startTime = Date.now();
        const check = () => {
            analyser.getByteFrequencyData(dataArray);
            for (let i = 0; i < bufferLength; i++) { if (dataArray[i] > maxNoise) maxNoise = dataArray[i]; }
            if (Date.now() - startTime < 1200) requestAnimationFrame(check);
            else {
                dynamicThreshold = Math.max(35, maxNoise + 12);
                isCalibrating = false;
                micStatus.innerText = "âœ… Seuil : " + Math.round(dynamicThreshold);
                setTimeout(() => micStatus.innerText = "ðŸŽ¤ Ã‰coute", 1000);
            }
        };
        check();
    }

    function addMessage(text, type) {
        const div = document.createElement('div');
        div.className = `bubble ${type}`;
        div.innerText = text;
        chatWindow.appendChild(div);
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    document.body.addEventListener('click', () => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        if (!isListening) startListening();
    }, { once: false });

    document.getElementById('inputText').addEventListener('keypress', (e) => { 
        if (e.key === 'Enter') sendSound(); 
    });
</script>
</body>
</html>
